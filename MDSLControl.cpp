//==================================================// MDSL ACCESS LIBRARY - Version 1.1 (2016)//==================================================// NCM - Núcleo de Computação Musical da UnB//  • Carlos Eduardo Mello//  • José de Abreu Carvalho Bacelar//==================================================// MDSLControl.cpp#include "MDSLControl.h"// ================================================= CONSTRUCTOR & DESTRUCTORMDSLControl::MDSLControl(void){	top.elemName = "dummmy";	top.elemData = "";	top.id = 0;	top.parent = NULL;	top.children = NULL;	top.next = NULL;		nextId = 0;		addressTable = NULL;	tableSize = 0;	currAddress = 0;		structureList = NULL;}MDSLControl::~MDSLControl(void){	// Destroy data tree		#ifdef _USE_COUT_DEBUG_    // DEBUG    cout << endl << "Releasing Data Tree..." << endl;    #endif    	ReleaseTree(top.children);		// Destroy address table	if(addressTable != NULL)		delete [] addressTable;		// Destroy structure list	ReleaseStructureList();}// ================================================================= INTERNAL CALLS// =============================================================== Tree// Recursive algorithm to parse a string containing an MDSL document and// build a data tree. As the tree is built, the document content (stored// in theContent) is passed from element to element and the portion that// belongs to each element is stored in its data field. The while loop// goes through the contents of every element on the same level while// recursion estracts the contents of each element. This way, the function// gets to the lowest levels of the tree and back up opening the next element,// and then down again until there is no more data inside any fields, execept// in the lowest levels, where the data is supposed to be placed.EP MDSLControl::LoadTree(MDSLNodePtr theNode){	EP ep = EPzeroERROR;	string openTag, closeTag;	string newContent;	MDSLNodePtr newNode = NULL;	long openTagStart, openTagEnd;	long closeTagStart;	//long contentSize = 0;	 	string & theContent = GetString(theNode);		#ifdef _USE_COUT_DEBUG_	// DEBUG	cout << endl;	cout << "[MDSLLoadTree]" << endl;	cout << endl << "\t-->theContent: " << theContent;	cout << endl;	#endif		while(theContent.size() != 0)	{	    #ifdef _USE_COUT_DEBUG_	    // DEBUG	    cout << endl << "\tExtraindo o proximo elemento deste nivel..." << endl;	    #endif	    		// Find openTag's starting tag mark in theContent string and mark its position:		openTagStart = theContent.find('<',0);		if(openTagStart == string::npos)			return EPopenTagNotFoundERROR;					// Find openTag's ending tag mark in theContent string and mark its position:			openTagEnd = theContent.find('>',openTagStart);		if(openTagEnd == string::npos)			return EPinvalidOpenTagERROR;				// copy text between starting and ending marks to openTag:			openTag = theContent.substr(openTagStart, (openTagEnd - openTagStart + 1));				#ifdef _USE_COUT_DEBUG_		// DEBUG		cout << endl;	    cout << "\t-->Elemento - OpenTag: " << openTag;	    cout << endl;		#endif				// Test openTag:		if(!ValidTag(openTag))			return EPinvalidOpenTagERROR;					// Create closeTag from openTag:		closeTag = openTag;		closeTag.insert(1, "/");				#ifdef _USE_COUT_DEBUG_		// DEBUG		cout << endl;	    cout << "\t-->Elemento - CloseTag: " << closeTag;	    cout << endl;		#endif				// Find closeTag in theContent string and mark its position:		closeTagStart = theContent.find(closeTag, openTagEnd);		if(closeTagStart == string::npos)			return EPcloseTagNotFoundERROR;				//Remove tags from theContent string, using previously marked positions...		// and store the new string in newContent:		newContent = theContent.substr(openTagEnd + 1, closeTagStart - (openTagEnd + 1));				// Remove the entire tag you just parsed from theContent. This way, the next time...		// through the loop, you will start with the the next tag, if it exists:		theContent.erase(0, (closeTagStart + closeTag.size() + 1));				#ifdef _USE_COUT_DEBUG_		// DEBUG		// verify newContent		cout << endl;	    cout << "\t-->Conteudo extraido do elemento: " << newContent;		cout << endl;				// DEBUG		// Verify what was left in theContent for the next time throught the loop		cout << endl;	    cout << "\t-->Conteudo restante: " << theContent;		cout << endl;		#endif				// Creat new element node with the data from the current tags and insert in tree:		newNode = InsertNewElement(theNode, StripTagMarks(openTag), newContent);		if(newNode == NULL)			return EPinsuficientMemoryERROR;					// Recursion (Danger Will Robinson!!)		ep = LoadTree(newNode);		switch(ep)		{			case EPopenTagNotFoundERROR:				// this means there are no more tags under this new node				#ifdef _USE_COUT_DEBUG_				// DEBUG				cout << endl << "\tTag nao encontrado --> Voltando ao nivel anterior..." << endl;				#endif				break;											case EPinvalidOpenTagERROR:			case EPcloseTagNotFoundERROR:			case EPinsuficientMemoryERROR:				// these conditions are irrecoverable				return ep;				break;					} // end switch			} // end while		// Clear theContent string	// You only need one of these calls. Comment out the one that doesn't	// work with your compiler...	// theContent.clear();	theContent.resize(0); 		return ep;}// end function// The following method accesses the string content...// of an MDSL tree node in order to search for tags (see MDSLLoadTree())// It returns a reference to the node's internal string// Therefore it can be used to modify it.// This method can only be used during parsing.string & MDSLControl::GetString(MDSLNodePtr theNode){	return theNode->elemData; }// This method checks the content of a given tag, to make sure it...// complies with the MDSL specification: only certain ASCII characters are allowed...// Anything other than leters, numbers and tag marks (<,>,/) is rejected!bool MDSLControl::ValidTag(string theTag){	long tagLength = theTag.size();	char ch;		for(int i = 0; i < tagLength; i++)	{	    ch = theTag[i];	    if  ( ! (                    // if the character is not one of these:	            ((ch >= 65) && (ch <= 90))  ||    // uppecase letters	            ((ch >= 97) && (ch <= 122)) ||    // lowercase letters	            ((ch >= 48) && (ch <= 57))  ||    // numerals	                            (ch == 47)  ||    // slash '/'	                            (ch == 60)  ||    // less than '<'	                            (ch == 62)        // greater than '>'	            )	       )	        return false; // invalid tag	}		#ifdef _USE_COUT_DEBUG_	// DEBUG	cout << endl;	cout << "\t[MDSLValidTag]";	cout << endl << "\t--> Tag OK!";	cout << endl;	#endif		return true;}// This method removes the tag marks from a given tag and returns it 'clean'string MDSLControl::StripTagMarks(string theTag){	long pos = 0;	// Find and remove starting mark if any	pos = theTag.find('<', 0);	if(pos != string::npos)	    theTag.erase(pos,1);	// Find and remove ending mark if any	pos = theTag.find('>', 0);	if(pos != string::npos)	    theTag.erase(pos,1);	// Find and remove close tag mark if any	pos = theTag.find('/', 0);	if(pos != string::npos)	    theTag.erase(pos,1);		#ifdef _USE_COUT_DEBUG_	// DEBUG	cout << endl;	cout << "\t[MDSLStripTagMarks]";	cout << endl<< "\t--> Tag sem as marcas: " << theTag;	cout << endl;	#endif		return theTag;}// This method creates a new element node and inserts it in the tree bellow the given parentNode...// If the parentNode has no children, the newNode opens the children list. If it has other children,// the function goes through the list and inserts the newNode at the end.MDSLNodePtr MDSLControl::InsertNewElement(MDSLNodePtr parentNode, string elementName, string theContent){	MDSLNodePtr newNode = NULL;	MDSLNodePtr last = NULL;		// Get a new node structure:	newNode = new MDSLNode;	if(newNode == NULL)		return newNode;			// Fill in the Structure:	newNode->elemName = elementName;	newNode->elemData = theContent;	newNode->id = nextId++;	newNode->parent = parentNode;// store the parent's address (for tree navigation)	newNode->children = NULL;	newNode->next = NULL;		// Insert it in parentNode's list of children:		// Check if parentNode has any children...	last = parentNode->children;	if(last == NULL)	{	    // ...if not, insert newNode as the first child in the list	    parentNode->children = newNode;	}	else	{	    // ...otherwise, go through the list...    	while(last->next != NULL)    		last = last->next;    	// ...put it in the end...    	last->next = newNode;     }		#ifdef _USE_COUT_DEBUG_	cout << endl;	cout << "\t[MDSLInsertNewElement]";	cout << endl << "\t--> Elemento inserido!";	cout << endl;	#endif		return newNode;}long MDSLControl::GetID(MDSLNodePtr theNode){    return theNode->id;}MDSLNodePtr MDSLControl::GetNode(long nodeId){    if(addressTable == NULL)        return NULL;            for(long i = 0; i < tableSize; i++)        if(addressTable[i].id == nodeId)            return addressTable[i].node;        return NULL;}void MDSLControl::ReleaseTree(MDSLNodePtr theNode){	MDSLNodePtr currNode, lastNode;		if(theNode == NULL)	    return;		currNode = lastNode = theNode;	    do    {            // Move down the tree        ReleaseTree(currNode->children);        // move along this level's list        lastNode = currNode;            currNode = currNode->next;                #ifdef _USE_COUT_DEBUG_        cout << endl << "Deleting node: " << lastNode->elemName << " : " << lastNode << endl;        #endif                // release this node	    delete lastNode;    }while(currNode != NULL);}// =============================================================== Address Table// This method allocates memory for the address table.// Before using it, you must load the element tree with data// From a valid MDSL document.EP MDSLControl::PrepareAddressTable(long tSize){    EP ep = EPzeroERROR;        // First we verify if the requested table size is valid...    if(tSize > 0)    {        // If the size is valid, we check if there is a previous table...        if(addressTable)        {            // if it exists, we delete and reset pointers and counters...            delete [] addressTable;            addressTable = NULL;            tableSize = 0;        }                // Then we allocate memory for the new table...        addressTable = new MDSLAddress[tSize];        if(addressTable)        {            // if allocation is successful, we            // rememeber the size of the new table...            tableSize = tSize;        }        else        {            return EPinsuficientMemoryERROR;        }    }    else    {        return EPInvalidTableSizeERROR;    }        return ep;}// This method goes through the element tree, after it is successfully loaded,// and fills the address lookup table with node ids and node pointers. // This table is used to speed up elment searching during data retrieval.EP MDSLControl::LoadAddressTable(MDSLNodePtr theNode){    EP ep = EPzeroERROR;    MDSLNodePtr currNode = theNode;        // Check if memory for table was allocated correctly...    if(addressTable == NULL)        return EPemptyTreeERROR; // if not, exit.        while(currNode != NULL)    {        // Store this element's id and address in the table:            addressTable[currAddress].id = currNode->id;        addressTable[currAddress].node = currNode;                #ifdef _USE_COUT_DEBUG_        // Showing address table entries...        cout << endl;        cout << "Address " << currAddress << " --> id = " << addressTable[currAddress].id << " node address = ";        cout << addressTable[currAddress].node << "." << endl;        #endif                // Increment the table index:        currAddress++;                 // move down to the next level        ep = LoadAddressTable(currNode->children);                // move along the children list        currNode = currNode->next;           }        return ep;} EP MDSLControl::AddAddress(MDSLAddress newAddress){    EP ep = EPzeroERROR;    long i, n;        // calculate space for new address...    n = tableSize + 1;        // allocate memory to include new address...    MDSLAddress * newTable = new MDSLAddress[n];    if(newTable)    {        // If alocation was successful, but original table        // was empty,        if (!addressTable)        {            //assign new table to table pointer...            addressTable = newTable;                        // and store new address on the table...            addressTable[0] = newAddress;        }        else        {            // otherwise copy existing addresses to new buffer...            for(i = 0; i < tableSize; i++)                newTable[i] = addressTable[i];                        // then copy new address to the last position...            newTable[i] = newAddress;                        #ifdef _USE_COUT_DEBUG_            cout << endl << "newTable[]" << endl;            for(i = 0; i < n; i++)                cout << "id = " << newTable[i].id << " node address = " << newTable[i].node << "." << endl;            #endif                        // delete the old table...            delete [] addressTable;                        // point to the new one...            addressTable = newTable;        }                // and finally update the address count...        tableSize = n;    }    else    {        ep = EPinsuficientMemoryERROR;    }    return ep;}// =============================================================== Strucure Liststring MDSLControl::ExtractParam(string & theLine){     long pos = 0;     char c = 0;     string param;         // Get first char:     c = theLine[pos];          // find end of parameter:     while(c != 32 && c != 9)         c = theLine[pos++];          // copy then remove parameter:     param = theLine.substr(0, pos-1);     theLine.erase(0, pos);          // starting with next char:     pos = 0;     c = theLine[pos];     // find and remove white space:     while(c == 32 || c == 9)         c = theLine[pos++];     theLine.erase(0, pos);                   return param;}void MDSLControl::InsertDefLink(MDSLElemDefPtr newDef){    MDSLElemDefPtr temp;        // start at top of list    temp = structureList;        // If the list is empty...    if(temp == NULL)        structureList = newDef; // start the list with this link    else    {        // otherwise...        // search for last link        while(temp->next != NULL)            temp = temp->next;               // Insert new link        temp->next = newDef;         }   }// This method loads the structure list contained in a string object.// The list may be obtained in any way, as long as it can be stored in a standard...// C++ string, in order to be loaded by this function.// This allows the calling code to read the list using any desireable strategy,// depending on platform and/or application approaches.// For instance, in a Classic Mac OS application, the structure list may be contained...// in the application's resource fork while in a Mac OS X environment, the list would...// probably be hidden inside the app's bundle; in a Windows version, it might be in...// a data file, within the application's sub-directories; etc.// Important: this method works with a string reference and modifies...// the contents of the original string!EP MDSLControl::LoadStructureList(string & structList){    EP ep = EPzeroERROR;    MDSLElemDefPtr   newDef = NULL;    string temp, param;    long endOfLine = 0, indx;    char c = 0;    // stack to store definition links (child_types) for each element definition    stack<long> defLinks;    stack<long> reverseLinks;    long lineNum = 0; // line index numbers retrieved from stack    MDSLElemDefPtr currDefLink, searchItem;        #ifdef _USE_COUT_DEBUG_    // DEBUG    cout << endl << "Loading Structure List..." << endl;    #endif        // Check if string is empty so we don't waste time    if(structList.size() == 0)        return EPemptyStructListERROR;        // Extract each line and check its content    while(structList.size() != 0)    {        // check for new line char        endOfLine = structList.find('\r', 0);        // If there is no return...        if(endOfLine == string::npos)            return EPbadStructListERROR; // the list is invalid        else        {            // copy then remove line from list            temp = structList.substr(0, endOfLine);            structList.erase(0, endOfLine + 1);                        // If we copied just a return ...             if(temp.size() <= 1)                continue; // get next line                        // get first char:            c = temp[0];            // line may not start with white sapce:            if(c == 32 || c == 9) // if c is space or tab                return EPbadStructListERROR;            // if this is a comment line            if(c == 47) // if c is '/'                continue; // get next line            // Create new element definition structure...            newDef = new MDSLElemDef;                        // If memory allocation was not sucessful...             if(newDef == NULL)                return EPcouldntCreateDefLinkERROR; // ...we can't continue            else            {                // put a safety terminator at each empty pointer on this link                newDef->next = NULL;                newDef->typeList = NULL;                                // then extract and store each parameter...                indx = StringToLong(ExtractParam(temp));                newDef->nameTag = ExtractParam(temp);                newDef->mode = StringToLong(ExtractParam(temp));                newDef->sibs = StringToLong(ExtractParam(temp));                newDef->textType = StringToLong(ExtractParam(temp));                if(newDef->mode != 0)                {                    newDef->numOfTypes = StringToLong(ExtractParam(temp));                    if(newDef->numOfTypes <= 0)                        return EPbadStructListERROR;                                        for(int i = 0; i < newDef->numOfTypes; i++)                    {                        // store each element index in the stack for later...                        defLinks.push(StringToLong(ExtractParam(temp)));                    }                }                else                {                    newDef->numOfTypes = 0;                } // end else                                // Now insert the new definition line in the structure list                InsertDefLink(newDef);           } // end else             } // end else    } // end while 1        // Now we have to restack the line indexes, so we can...         while(!defLinks.empty())    {        #ifdef _USE_COUT_DEBUG_        // Show index numbers as they are popped out of the stack:        cout << endl << defLinks.top();        #endif                reverseLinks.push(defLinks.top());        defLinks.pop();    }        // ...Move forward down the list, replacing them with addresses:        // start at top of list    currDefLink = structureList;        // If the list is empty...    if(currDefLink == NULL)        return EPcouldntStoreDefLinkAddressesERROR; // start the list with this link    else    {        // otherwise, go through each link,...        while(currDefLink->next != NULL)        {            // Check if this element has enclosed element types...            if(currDefLink->mode != 0)            {                // ...Then allocate memory for type list, to store the                 // addresses of each element definition link:                currDefLink->typeList = new MDSLElemDefPtr[currDefLink->numOfTypes];                if(currDefLink->typeList == NULL)                    return EPcouldntCreateTypeListERROR;                // retrieve each line index number form the stack...                for(int i = 0; i < currDefLink->numOfTypes; i++)                {                   // For each number...                   lineNum = reverseLinks.top();                   reverseLinks.pop();                   // ...start counting at the top of structure list,                   searchItem = structureList;                   // move as many elements as the line number value...                   while(lineNum--)                   {                        searchItem = searchItem->next;                   }                   // store the corresponding definition link address                   currDefLink->typeList[i] = searchItem;                }            }            // move to next link            currDefLink = currDefLink->next;        }     }           return ep;}// This method verifies the structure of a single node in the date tree.// It looks in the structure list for the definition which corresponds// to the node's element name, and then checks if the node's parts are// properly structured. This method is called by a recursive function // which navigates the entire data tree looking for inconsistencies in// the document's structure (see MDSLCheckTree().bool  MDSLControl::CheckNode(MDSLNodePtr theNode){    bool nodeOK = true;    bool definitionFound = false;    string nodeName;    MDSLElemDefPtr tempDef = NULL;    MDSLNodePtr tempNode = NULL;    long elemCount = 0;        // First we get the name from the node...    nodeName = theNode->elemName;        // Then we look for the beginning of the structure list...    tempDef = structureList;        // Fail verification if  structure list is not loaded    if(tempDef == NULL)        return false;        // Now we try to find a corresponding definition line    while(tempDef != NULL)    {        if(tempDef->nameTag == nodeName)        {            definitionFound = true;            break;        }        tempDef = tempDef->next;    }        // Fail verification if cannot find a definition line for this element    if(!definitionFound)            return false;        // Otherwise go on checking...        // First get a pointer for this node's parent    tempNode = theNode->parent->children;        // Then go through the parent's child list and count the elements which    // have the same name tag as this node's name. After finding two elements,    // we already know if the the document complies with this elements definition.        while(tempNode != NULL && elemCount < 3)    {        if(tempNode->elemName == nodeName)            elemCount++;        tempNode = tempNode->next;    }        // Fail verification if number of elements does not match definition    if((tempDef->sibs == 1) && (elemCount > 1))        return false;      // Next we check the definition's mode...     if(tempDef->mode == 0)   // If this is a data element...   {        switch(tempDef->textType)        {            case 0:     // This element's data should be UTF 8 text                break;                            case 1:     // This element's data should be a number...                // Fail verification  if it's not:                if(!IsNumber(theNode->elemData))                    return false;                break;        } // end switch   }   else     // if this is a structure element (mode == 1)...   {        // go through this node's child list and compare its elements        // with the allowed element types in the definition:        tempNode = theNode->children;                while(tempNode != NULL)        {            // For each child, check if element name is allowed            definitionFound = false;            for(short i = 0; i < tempDef->numOfTypes; i++)            {                if(tempDef->typeList[i]->nameTag == tempNode->elemName)                {                    definitionFound = true;                    break;                }            }            // Fail verification if element is not find in typeList            if(!definitionFound)                   return false;           tempNode = tempNode->next;        }   } // end else        // If we got to this point, it means no structure erros were found, and...    // the node is OK.    return nodeOK;}// This method navigates through the data tree, checking each node // against the structure list (see MDSLCheckNode()).bool MDSLControl::CheckTree(MDSLNodePtr theNode){    bool treeOK = false;    MDSLNodePtr currNode = theNode;       while(currNode != NULL)    {        #ifdef _USE_COUT_DEBUG_        cout << endl << "Checking next node..." << endl;        #endif                // If this node has any children...        if(currNode->children != NULL)  // ...move down to the next level        {            treeOK = CheckTree(currNode->children);            // If any level is bad, the entire tree is bad, so...            if(!treeOK)                return false; // we can return without any further checking        }             // Now check the node against the structure list       treeOK = CheckNode(currNode);       // If any node is bad, the entire tree is bad, so...       if(!treeOK)           return false; // we can return without any further checking              // move along the children list        currNode = currNode->next;           }        // If we got to this point, the tree is OK (so far...)    return treeOK;}void MDSLControl::ReleaseStructureList(void){	MDSLElemDefPtr currDef, lastDef;	currDef = lastDef = structureList;		while(currDef != NULL)	{		if(currDef->typeList != NULL)			delete [] currDef->typeList;		currDef = currDef->next;		delete lastDef;		lastDef = currDef;	}}//========================================================================= PARSINGEP MDSLControl::OpenFile(string fileName, string structListFile){	EP ep = EPzeroERROR;	char ch = 0;	string	content;	ifstream MDSLin;		// open file to get the MDSLL document	MDSLin.open(fileName.c_str());	if(!(MDSLin.is_open()))            return EPfileNotFoundERROR;            	// Load the contents of this file to the content string	while(MDSLin.get(ch))	{		content += ch;	}			// Close File    MDSLin.close();		// Read document from file content...	top.elemData = content;	// clear content string to save memory. This will avoid duplicate copies	// of large data files...	content.resize(0); 		#ifdef _USE_COUT_DEBUG_	cout << endl;	cout << "Loading data tree..." << endl<< endl;	#endif		// Start parsing the document	ep = LoadTree(&top);		// If tree loaded OK...	if(ep == EPzeroERROR || ep == EPopenTagNotFoundERROR)	{	    // Allocate memory for the address table, so that it can receive addresses		ep = PrepareAddressTable(nextId);		if(ep != EPzeroERROR)        return ep;                #ifdef _USE_COUT_DEBUG_		cout << endl << endl;		cout << "Loading address table..." << endl<< endl;		#endif				// Load ids and pointers into the address table		ep = LoadAddressTable(top.children);		if(ep != EPzeroERROR)	        return ep;	                    if(structListFile != "")        {             cout << endl << "[OPENING STRUCTURE LIST FILE]..." << endl;                        // associate file stream with the file containing the structure list            MDSLin.open(structListFile.c_str());            if(!(MDSLin.is_open()))                return EPStructureListNotFoundERROR;                        // Clear input stream of eof            MDSLin.clear(iostream::goodbit);                        // Load the contents of this file to the content string            while(MDSLin.get(ch))            {                content += ch;            }                        // CLose File            MDSLin.close();                         cout << endl << "[LOADING STRUCTURE LIST]..." << endl;            // Load Structure List            ep = LoadStructureList(content);                        // content.resize(0);            cout << endl << "[CHECKING DATA TREE]..." << endl;            // Verify Structure            if(!CheckTree(GetNode(0)))                return EPinvalidDocumentERROR;        }    }	return ep;}// ============================================================================== GETTING INFOlong MDSLControl::GetNumberOfElements(long nodeId){	long elemCount = 0;	MDSLNodePtr theNode = NULL;	MDSLNodePtr temp = NULL;		theNode = GetNode(nodeId);	if(theNode != NULL)	{	    temp = theNode->children;	    if(temp == NULL)	        return 0; // no elements under this node	    else	    {	        // Move through the children list and count the elements	        do	        {	            elemCount++;	            temp = temp->next;	            	        } while(temp != NULL);	    }	}		return elemCount;}long MDSLControl::GetNumberOfElements(long nodeId, string tagName){	long elemCount = 0;	MDSLNodePtr theNode = NULL;	MDSLNodePtr temp = NULL;		theNode = GetNode(nodeId);	if(theNode != NULL)	{	    temp = theNode->children;	    if(temp == NULL)	        return 0; // no elements under this node	    else	    {	        // Move through the children list and count the elements...	        // that have the same name as the tagName provided	        do	        {	            if(temp->elemName == tagName)	                elemCount++;	            temp = temp->next;	            	        } while(temp != NULL);	    }	}		return elemCount;}long MDSLControl::GetMainID(void){	return top.children->id;}// The following method returns the id of a requested element.// The element is requested as the nth (index) element of a given type (elemTag)...// ...under another element (fatherId).// This method makes use of the address table, so it can only be called after...// both the tree and the table are successfully loaded.long MDSLControl::GetID(long fatherId, string elemTag, long index){	long elemID = -1; // invalid Id number	long elemCount = 0;	MDSLNodePtr fatherNode = NULL;	MDSLNodePtr currNode = NULL;		// First find the node in the address table:	fatherNode = GetNode(fatherId);		// If we have a valid node...	if(fatherNode != NULL)	{    	 // Start with the father's first child...    	 currNode = fatherNode->children;    	     	 // if there are no children, loop ends before starting and     	 // function returns an invalid Id number as an error signal    	 while(currNode != NULL)        {            if(currNode->elemName == elemTag)            {                if(elemCount == index)                {                    return currNode->id;                }                else                {                    elemCount++;                }            }                        currNode = currNode->next;        }	}	return elemID;}// This method returns the Tag (i.e.: element name) of the element...// refered to by nodeId. As it relies on the address table, it...// cannot be used until the table is loaded.string MDSLControl::GetTag(long nodeId){	string tag = "";	MDSLNodePtr theNode = NULL;		// Look up the element's address	theNode = GetNode(nodeId);	// If we can find the desired element...	if(theNode != NULL)	    return theNode->elemName; // we return its name tag	    	// ... otherwise we return an empty string	return tag;}// ============================================================================== GETTING DATA// returns a copy of the node's data stringstring MDSLControl::GetDataString(long nodeId){	MDSLNodePtr theNode = NULL;	string emptyString = "";		theNode = GetNode(nodeId);		if(theNode != NULL)	    return theNode->elemData;        return emptyString;}// returns the node's data string converted to a long integerlong MDSLControl::GetDataLong(long nodeId){	long        longData = 0;	string      numString;		// Get Data String...	numString = GetDataString(nodeId);		// Convert to number	longData = StringToLong(numString);		// Return number	return longData;}// returns the node's data string converted to a double floatdouble	MDSLControl::GetDataDouble(long nodeId){	double      doubleData = 0.0;	string      numString;		// Get Data String...	numString = GetDataString(nodeId);		// Convert to number...	doubleData = StringToDouble(numString);		// return number	return doubleData;}// ============================================================================== SETTING DATA// This method starts a new data tree from scratch.long    MDSLControl::CreateMainElement(string tag){    EP ep = EPzeroERROR;    MDSLAddress newAddress;        if(!top.children)    {        top.children = new MDSLNode;        if(top.children)        {            top.children->id = 0;            top.children->elemName = "class";            top.children->next = NULL;            top.children->parent = &top;            top.children->children = NULL;            nextId++;                        newAddress.id = top.children->id;            newAddress.node = top.children;            ep = AddAddress(newAddress);            if (ep == EPzeroERROR)                return top.children->id;        }    }        return -1;}// This method converts the parent id to a node ptr, performs structure check and// calls the internal version of the InsertElement.EP MDSLControl::AddNewElement(long parentId, string tag, string data){    EP ep = EPzeroERROR;    MDSLNodePtr parentNode = NULL;    MDSLNodePtr newNode = NULL;    parentNode = GetNode(parentId);    if(parentNode)    {        // ==========================================================        // TO BE DEVELOPED!!        // ==========================================================        // - TEST IF THIS ELEMENT IS VALID AS A CHILD OF THIS PARENT...        // - CHECK IF THE ELEMENT'S TAG IS FOR STRUCTURE OR DATA...        // - IF DATA ELEMENT, CHECK IF TEXT OR NUMERICAL...        // - VALIDATE NUMERICAL FIELD...        // ==========================================================                // INSERT ELEMENT IN DATA TREE...        newNode = InsertNewElement(parentNode, tag, data);        if(newNode)        {            MDSLAddress newAddress;            newAddress.id = newNode->id;            newAddress.node = newNode;            ep = AddAddress(newAddress);        }        else        {            return EPCouldntAddElementERROR;        }            }    return ep;}EP MDSLControl::SetDataString(long nodeId, string stringData){	EP ep = EPzeroERROR;    MDSLNodePtr theNode = GetNode(nodeId);    if(theNode)    {        theNode->elemData = stringData;    }    else        ep = EPCouldntSetDataStringERROR;		return ep;}EP MDSLControl::SetDataLong(long nodeId, long theValue){	EP ep = EPzeroERROR;    string dataString = to_string(theValue);        MDSLNodePtr theNode = GetNode(nodeId);    if(theNode)    {        theNode->elemData = dataString;    }    else        ep = EPCouldntSetDataStringERROR;    	return ep;}EP MDSLControl::SetDataDouble(long nodeId, double theValue){	EP ep = EPzeroERROR;    string dataString = to_string(theValue);	    MDSLNodePtr theNode = GetNode(nodeId);    if(theNode)    {        theNode->elemData = dataString;    }    else        ep = EPCouldntSetDataStringERROR;    	return ep;}// ============================================================================== NUMBER UTILITIES // This method works only with integer bases and positive integer exponentslong MDSLControl::Power(long e, long b){    long thePower = 1;        // discard negative exponents    if(e < 0)        return 0;    // X^0 = 1    if(e == 0)        return 1;    // calculate power        while(e--)        thePower *= b;        return thePower;}bool MDSLControl::IsNumber(string theString){	int decPoints = 0; // decimal points count	long sLen = theString.size();		// Check characters...	for(int i = 0; i < sLen; i++)	{	    // If any bad characters are found...	    if  (   	            // chars can only be a digit (0-9), a decimal point or a minus sign:	            (theString[i] < '0' || theString[i] > '9') && 	            (theString[i] != '.') && 	            (theString[i] != '-')	        )	        return false; // This is not a number!	        	    // if char is a minus sign, it must be in the begining, ...	    if( (theString[i] == '-') && (i != 0))	        return false; // ...otherwise this is not a number!	        	    // count decimal points	    if(theString[i] == '.')	        decPoints++;	}		//  there shouldn't be more than one decimal point...	if(decPoints > 1)	    return false;	    	// If we got this far then...	return true; // ...OK, it's a number.}// This method returns the element data converted to a number, if possible.// Obs.: This method makes use of MDSLPower() which, in turn, ...// works only with integer bases and positive integer exponents.long MDSLControl::StringToLong(string numString){    long        longData = 0;	long        decPos = string::npos;	//int         minusPos = string::npos;	int         numSign = 1;        // Check if this string is a number -- if a bad string reaches...    // the function, we don't want to crash or deliver garbage.    	if(!IsNumber(numString))	    return longData; // if it isn't a number, return 0		// Check the string's length	long sLen = numString.size();	if(sLen == 0)	    return longData;  // if it is empty, return 0		// If the number is negative...	if(numString[0] == '-')	{	    // remove minus sign	    numString.erase(0,1);	    // and store it as a number for later...	    numSign = -1;	    // update string length to account for minus sign removal:	    sLen--; 	}		// Locate the decimal point...	decPos = numString.find('.', 0);		// If this is an integer we convert it...	if(decPos == string::npos)	{	    // convert each character from ascii to a number...	    // then multiply it by the corresponding power of 10,...	    // according to it's position in the number. Powers start	    // at 0 (sLen - sLen) and go through sLen (slen - 0)	    for(long i = sLen; i > 0; i--)	        longData += (((numString[i-1]) - 48) * (Power((sLen - i), 10)));	}		// restore sign...	longData *= numSign;		return longData;}// This method returns the element data converted to a number, if possible.// Obs.: This method makes use of MDSLPower() which, in turn, ...// works only with integer bases and positive integer exponents.double MDSLControl::StringToDouble(string numString){    double		doubleData = 0.0;	long        decPos = string::npos;	//long        minusPos = string::npos;	long        numSign = 1;		// Check if this string is a number -- if a bad string reaches...    // the function, we don't want to crash or deliver garbage.    	if(!IsNumber(numString))	    return doubleData; // if it isn't a number, return 0		// Check the string's length	long sLen = numString.size();	if(sLen == 0)	    return doubleData; // if it is empty, return 0		// If the number is negative...	if(numString[0] == '-')	{	    // remove minus sign	    numString.erase(0,1);	    // and store it as a number for later...	    numSign = -1;	    // update string length to account for minus sign removal:	    sLen--; 	}		// Locate the decimal point...	decPos = numString.find('.', 0);		// If this is an integer we convert it...	if(decPos == string::npos)	{	    // convert each character from ascii to a number...	    // then multiply it by the corresponding power of 10,...	    // according to it's position in the number. Powers start	    // at 0 (sLen - sLen) and go through sLen (slen - 0)	    for(long i = sLen; i > 0; i--)	        doubleData += (((numString[i-1]) - 48) * Power((sLen - i), 10));	}	else	{	    // if it is a floating point number we process each side of the decimal point seperatly:	    // first we add the right side - the places to the right are divided by successive powers of 10	    for(long i = decPos + 1; i < sLen; i++)	    {	        doubleData += ((double)((numString[i]) - 48) / (Power(i-decPos, 10)));	    }	    // then we add the left side as before	    for(long i = decPos; i > 0; i--)	    {	        doubleData += (((numString[i-1]) - 48) * Power((decPos - i), 10));	    }	}		// restore sign...	doubleData *= numSign;		// return number	return doubleData;}	// WRITING FILEEP MDSLControl::WriteToFile(string fileName){	EP ep = EPzeroERROR;    string	content;    ofstream outputFile;        // open file to store MDSL document    outputFile.open(fileName.c_str());    if(!(outputFile.is_open()))        return EPfileNotFoundERROR;        // If data tree is valid,    if(top.children)    {        #ifdef _USE_COUT_DEBUG_        cout << endl << "[Saving Data Tree to File]:" << endl;        #endif                // we write every node to the output file...        // (this call requires a valid, open output stream)        WriteTree(outputFile, top.children);    }        // Close File    outputFile.close();    	return ep;}// Recursive call to navigate the data tree and write it's content to filebool MDSLControl::WriteTree(ofstream & outputFile, MDSLNodePtr entryPoint){    bool doneHere = false;    MDSLNodePtr currNode = entryPoint;        // First we check if this is a valid node...    while(currNode != NULL)    {        #ifdef _USE_COUT_DEBUG_        cout << endl << "writing open tag: " << currNode->elemName << endl;        #endif                // then we insert the opening tag for this node...        outputFile << "<" << currNode->elemName << ">";                // if the node has any children...        if(currNode->children != NULL)        {            outputFile << "\n";            // ...we move down to the next level ...            doneHere = WriteTree(outputFile,currNode->children);        }        else // if there are no children, there must be data...        {            #ifdef _USE_COUT_DEBUG_            cout << endl << "Data: " << currNode->elemData << endl;            #endif            // we insert this node's data in the file...            outputFile << currNode->elemData;        }                #ifdef _USE_COUT_DEBUG_        cout << endl << "writing close tag: " << currNode->elemName << endl;        #endif                // after we are done with the node's children,        // we write the closing tag and...        outputFile << "</" << currNode->elemName << ">\n";                // move along the children list...        currNode = currNode->next;    }        // once we've been to all nodes on this level, we are done...    return true;}